# ADR-0009: Connection Authentication

## Status

**Proposed** — Awaiting implementation (Priority: H, Score: 9)

## Context

Currently, any client that can reach the server's WebSocket or stdio transport can:
- Create unlimited sessions
- Execute arbitrary commands
- Access all session data

This is acceptable for single-user local development but becomes a security risk when:
- Server binds to public interface
- Multi-user deployment is needed
- Server exposed via reverse proxy

### Threat Model

| Threat | Current Risk | Mitigated By |
|--------|--------------|--------------|
| Unauthorized access | High | Authentication |
| Session hijacking | High | Session ownership |
| Resource exhaustion | Medium | Rate limiting (already implemented) |
| Command injection | Low | Input validation (already implemented) |

## Decision

We will implement **token-based authentication** with the following design:

### 1. Authentication Flow

```
Client                          Server
  │                               │
  │──── Connect (WebSocket) ─────►│
  │                               │
  │◄─── server_ready (no auth) ───│  (limited: only version info)
  │                               │
  │──── authenticate command ────►│
  │       { token: "xxx" }        │
  │                               │
  │◄─── auth_success/auth_fail ───│
  │                               │
  │──── Full command access ─────►│
  │                               │
```

### 2. Token Types

| Type | Use Case | Generation |
|------|----------|------------|
| `static` | Development, testing | Config file, env var |
| `jwt` | Production, multi-user | External identity provider |
| `api_key` | Service-to-service | Generated by server admin |

### 3. Command Changes

```typescript
// New command
type AuthenticateCommand = {
  type: "authenticate";
  token: string;
  tokenType?: "static" | "jwt" | "api_key"; // default: static
};

// Response
type AuthenticateResponse = {
  success: boolean;
  error?: string;
  expiresAt?: string; // ISO timestamp for JWT
  clientId?: string;  // Identity from token
};
```

### 4. Server Configuration

```typescript
interface AuthConfig {
  enabled: boolean;
  // Static token (simplest)
  staticToken?: string;
  // JWT validation
  jwtSecret?: string;
  jwtIssuer?: string;
  // API key validation
  apiKeyFile?: string; // path to keys file
  // Grace period (allow unauthenticated for N seconds)
  gracePeriodMs?: number;
}
```

### 5. Backward Compatibility

- **Default:** Authentication disabled (`auth.enabled: false`)
- **Grace period:** Configurable window for clients to authenticate
- **Unauthenticated mode:** All commands work (current behavior)
- **Authenticated mode:** Only `authenticate` and `server_ready` allowed before auth

## Implementation Phases

### Phase 1: Static Token (v1.1.0)

- [ ] Add `AuthConfig` to server configuration
- [ ] Add `authenticate` command
- [ ] Track authenticated state per connection
- [ ] Reject non-auth commands when auth required
- [ ] Add tests for auth flow

### Phase 2: JWT Support (v1.2.0)

- [ ] Add JWT validation
- [ ] Extract identity claims (sub, roles)
- [ ] Add session ownership (sessions belong to identities)
- [ ] Add tests for JWT flow

### Phase 3: Multi-user Isolation (v2.0.0)

- [ ] Session visibility scoped to identity
- [ ] Cross-session access control
- [ ] Admin role for cross-user access
- [ ] Add tests for multi-user isolation

## Consequences

### Positive

- Security: Unauthorized access blocked
- Audit: Commands traceable to identities
- Scalability: Multi-user deployment possible

### Negative

- Complexity: New auth layer in server
- Client changes: All clients must authenticate
- Operations: Token management overhead

### Mitigations

| Risk | Mitigation |
|------|------------|
| Breaking local dev | Default disabled, clear docs |
| Token leakage | Support rotation, short-lived JWTs |
| Client compatibility | Grace period, clear error messages |

## Alternatives Considered

### Alternative 1: mTLS

Mutual TLS at transport layer.

**Rejected:** Complex PKI management, doesn't work well with WebSocket browsers.

### Alternative 2: OAuth2 Flow

Full OAuth2 authorization code flow.

**Rejected:** Overkill for single-server use case, requires external IdP setup.

### Alternative 3: No Authentication (Current)

Trust all connections.

**Rejected:** Blocks multi-user deployment, security risk on public networks.

## References

- OWASP WebSocket Security Cheat Sheet
- RFC 6750: Bearer Token Usage
- JWT Best Practices (RFC 8725)

## Decision Log

| Date | Decision | Rationale |
|------|----------|-----------|
| 2026-02-28 | Token-based auth | Simplest path to multi-user support |
| 2026-02-28 | Static tokens first | Fastest implementation, covers dev use case |
| 2026-02-28 | Grace period | Backward compatibility during migration |
